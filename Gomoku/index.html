<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>极简 AI 五子棋</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    :root {
      --primary: #4361ee;
      --primary-light: #4895ef;
      --primary-dark: #3551d1;
      --secondary: #3a0ca3;
      --accent: #f72585;
      --success: #4cc9f0;
      --warning: #f8961e;
      --danger: #f94144;
      --light: #f8f9fa;
      --dark: #212529;
      --board-bg: #f3d5b5;
      --board-lines: #7f5539;
      --black-piece: #0a0a0a;
      --white-piece: #f0f0f0;
      --radius-sm: 6px;
      --radius-md: 10px;
      --radius-lg: 14px;
      --shadow-sm: 0 2px 4px rgba(0,0,0,0.08);
      --shadow-md: 0 4px 8px rgba(0,0,0,0.12);
      --shadow-lg: 0 8px 16px rgba(0,0,0,0.16);
      --font-main: 'Segoe UI', 'Microsoft YaHei', sans-serif;
      --transition-fast: all 0.2s ease;
      --transition-normal: all 0.3s ease;
    }
    
    body { 
      margin: 0; 
      font-family: var(--font-main); 
      background-color: #f0f2f5; 
      color: var(--dark); 
      line-height: 1.6;
      min-height: 100vh;
    }
    
    .app-container { 
      max-width: 1200px; 
      margin: 0 auto; 
      padding: 15px;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    header { 
      text-align: center; 
      padding: 15px; 
      margin-bottom: 20px; 
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      color: white; 
      border-radius: var(--radius-md); 
      box-shadow: var(--shadow-md);
      position: relative;
      overflow: hidden;
    }
    
    header::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(255,255,255,0.1) 10%, transparent 60%);
      z-index: 0;
      animation: rotateGradient 20s linear infinite;
    }
    
    @keyframes rotateGradient {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    header h1 { 
      margin: 0; 
      font-size: 28px; 
      position: relative;
      z-index: 1;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
      font-weight: 700;
      letter-spacing: 1px;
    }
    
    /* Fixed fullscreen button */
    #fullScreenButton {
      position: fixed;
      top: 15px;
      right: 15px;
      z-index: 1000;
      background: var(--primary);
      color: white;
      border: none;
      padding: 6px 10px;
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-sm);
      cursor: pointer;
      transition: var(--transition-normal);
      font-family: var(--font-main);
      font-weight: 600;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    #fullScreenButton::before {
      content: "⛶";
      font-size: 15px;
    }
    
    #fullScreenButton:hover {
      background: var(--primary-dark);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }
    
    /* Main content layout */
    .main-content { 
      display: flex; 
      flex-direction: row; 
      gap: 20px;
      flex: 1;
    }
    
    .left-panel { 
      flex: 3; 
      display: flex; 
      flex-direction: column; 
      align-items: center;
    }
    
    .right-panel { 
      flex: 2; 
      display: flex; 
      flex-direction: column; 
      gap: 15px;
    }
    
    .panel-card {
      background: white;
      border-radius: var(--radius-md);
      padding: 15px;
      box-shadow: var(--shadow-md);
      transition: var(--transition-fast);
      border: 1px solid rgba(0,0,0,0.05);
    }
    
    .panel-card:hover {
      box-shadow: var(--shadow-lg);
      transform: translateY(-2px);
    }
    
    /* Common section styles */
    .scoreboard, .timer { 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      gap: 10px; 
      font-size: 15px;
    }
    
    .scoreboard { 
      flex-wrap: wrap; 
      padding: 10px;
    }
    
    .score-box { 
      display: flex; 
      align-items: center; 
      gap: 8px; 
      background: var(--light); 
      padding: 8px 14px; 
      border-radius: 20px;
      box-shadow: var(--shadow-sm);
      transition: var(--transition-fast);
      border: 1px solid rgba(0,0,0,0.05);
    }
    
    .score-box:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }
    
    .score-label {
      color: var(--dark);
      font-weight: 600;
    }
    
    .player-score, .computer-score { 
      font-weight: bold; 
      font-size: 18px;
      min-width: 28px;
      text-align: center;
      text-shadow: 0 1px 1px rgba(0,0,0,0.1);
    }
    
    .player-score {
      color: var(--primary);
      background: rgba(67, 97, 238, 0.1);
      padding: 2px 6px;
      border-radius: 10px;
    }
    
    .computer-score {
      color: var(--secondary);
      background: rgba(58, 12, 163, 0.1);
      padding: 2px 6px;
      border-radius: 10px;
    }
    
    .controls-container { 
      display: flex; 
      flex-direction: column; 
      gap: 8px;
    }
    
    .controls, .extra-controls { 
      display: flex; 
      flex-wrap: wrap; 
      justify-content: center; 
      gap: 4px;
    }
    
    /* Buttons and selects */
    button, select { 
      background: var(--primary); 
      color: white; 
      border: none; 
      padding: 7px 12px; 
      border-radius: 20px; 
      font-size: 14px; 
      cursor: pointer; 
      transition: var(--transition-normal); 
      box-shadow: var(--shadow-sm);
      font-family: var(--font-main);
      font-weight: 600;
      outline: none;
      min-width: 80px;
      text-align: center;
      letter-spacing: 0.5px;
    }
    
    button:hover { 
      background: var(--primary-dark); 
      transform: translateY(-2px); 
      box-shadow: var(--shadow-md);
    }
    
    button:active { 
      transform: translateY(-1px);
    }
    
    select { 
      background-color: white; 
      color: var(--dark); 
      border: 1px solid #ddd;
      padding-right: 30px;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23333' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 10px center;
      background-size: 14px;
    }
    
    select:hover {
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.1);
      transform: translateY(-2px);
    }
    
    #resetScore { 
      background-color: var(--danger);
    }
    
    #resetScore:hover { 
      background-color: #e41b23;
    }
    
    #undo { 
      background-color: var(--warning);
    }
    
    #undo:hover { 
      background-color: #e67e22;
    }
    
    #saveGame, #loadGame, #replayGame {
      background-color: var(--success);
    }
    
    #saveGame:hover, #loadGame:hover, #replayGame:hover {
      background-color: #3db4ed;
    }
    
    #toggleSound {
      background-color: var(--secondary);
    }
    
    #toggleSound:hover {
      background-color: #2c0a7a;
    }
    
    /* Status container */
    #statusContainer { 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      gap: 8px; 
      background: var(--light); 
      padding: 12px; 
      border-radius: var(--radius-md); 
      font-size: 15px;
      margin: 8px 0;
      box-shadow: var(--shadow-sm);
      position: relative;
      overflow: hidden;
      min-height: 50px;
      border-left: 4px solid var(--primary);
    }
    
    #statusText {
      font-weight: 600;
      color: var(--dark);
    }
    
    #spinner { 
      animation: spin 1s linear infinite;
      font-size: 18px;
    }
    
    @keyframes spin { 
      0% { transform: rotate(0deg); } 
      100% { transform: rotate(360deg); }
    }
    
    /* Board container */
    .board-container { 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      margin: 15px 0;
      position: relative;
      padding: 5px;
      width: 100%;
      aspect-ratio: 1/1;
      max-width: 600px;
    }
    
    canvas { 
      width: 100%;
      height: 100%;
      border-radius: var(--radius-lg); 
      box-shadow: var(--shadow-lg);
      background-color: var(--board-bg);
      transition: var(--transition-normal);
      border: 1px solid #e0c9a6;
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
    }
    
    canvas:hover {
      transform: scale(1.01);
      box-shadow: 0 12px 24px rgba(0,0,0,0.2);
    }
    
    .timer {
      background: linear-gradient(to right, rgba(67, 97, 238, 0.05), rgba(76, 201, 240, 0.1));
      padding: 8px 15px;
      border-radius: 20px;
      margin-top: 10px;
      font-weight: 600;
      display: inline-flex;
      box-shadow: var(--shadow-sm);
      color: var(--dark);
      border: 1px solid rgba(67, 97, 238, 0.1);
    }
    
    /* Log and stats containers */
    .log-stats { 
      display: flex; 
      flex-wrap: wrap; 
      gap: 15px;
    }
    
    .log-container, .stats { 
      flex: 1; 
      min-width: 240px; 
      background: white; 
      border-radius: var(--radius-md); 
      box-shadow: var(--shadow-md); 
      padding: 15px; 
      height: 200px; 
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--primary-light) transparent;
      border: 1px solid rgba(0,0,0,0.05);
      transition: var(--transition-fast);
    }
    
    .log-container:hover, .stats:hover {
      box-shadow: var(--shadow-lg);
    }
    
    .log-container::-webkit-scrollbar, .stats::-webkit-scrollbar {
      width: 5px;
    }
    
    .log-container::-webkit-scrollbar-thumb, .stats::-webkit-scrollbar-thumb {
      background-color: var(--primary-light);
      border-radius: 3px;
    }
    
    .log-container h2, .stats h2 { 
      font-size: 18px; 
      color: var(--primary); 
      margin: 0 0 12px 0; 
      padding-bottom: 8px; 
      border-bottom: 2px solid rgba(67, 97, 238, 0.2);
      font-weight: 700;
      position: sticky;
      top: 0;
      background: white;
      z-index: 1;
    }
    
    .log-entry { 
      font-size: 13px; 
      margin: 5px 0; 
      padding: 6px 8px; 
      border-radius: var(--radius-sm);
      transition: var(--transition-fast);
      border-left: 3px solid transparent;
      line-height: 1.4;
    }
    
    .log-entry:hover {
      background-color: rgba(67, 97, 238, 0.05);
      border-left-color: var(--primary);
    }
    
    .stats p { 
      display: flex; 
      justify-content: space-between; 
      margin: 10px 0; 
      font-size: 14px;
      padding: 8px 10px;
      border-radius: var(--radius-sm);
      background-color: var(--light);
      transition: var(--transition-fast);
      border-left: 3px solid transparent;
    }
    
    .stats p:hover {
      background-color: rgba(67, 97, 238, 0.05);
      border-left-color: var(--primary);
      transform: translateX(2px);
    }
    
    .stats span {
      font-weight: 600;
      color: var(--primary);
      background: rgba(67, 97, 238, 0.1);
      padding: 1px 6px;
      border-radius: 10px;
    }
    
    /* Responsive design */
    @media (max-width: 768px) {
      .app-container { 
        padding: 10px;
      }
      
      header {
        padding: 12px;
        margin-bottom: 15px;
      }
      
      header h1 {
        font-size: 22px;
      }
      
      .main-content { 
        flex-direction: column;
        gap: 15px;
      }
      
      .panel-card {
        padding: 12px;
      }
      
      .scoreboard { 
        flex-wrap: wrap;
        padding: 8px;
      }
      
      .controls, .extra-controls { 
        flex-wrap: wrap;
      }
      
      button, select { 
        flex-grow: 1; 
        font-size: 13px; 
        padding: 6px 10px;
        min-width: 75px;
      }
      
      .log-container, .stats { 
        min-width: 100%; 
        height: 160px;
        padding: 12px;
      }
      
      .timer {
        font-size: 13px;
        padding: 6px 10px;
      }
      
      #fullScreenButton {
        top: 8px;
        right: 8px;
        padding: 5px 10px;
        font-size: 12px;
      }
      
      .board-container {
        max-width: 90vw;
      }
    }
    
    @media (min-width: 769px) and (max-width: 1100px) {
      .board-container {
        max-width: 500px;
      }
      
      .app-container {
        padding: 12px;
      }
    }
    
    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    @keyframes slideUp {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    .board-container {
      animation: slideUp 0.6s ease-out forwards;
    }
    
    .scoreboard, .controls-container {
      animation: slideUp 0.7s ease-out forwards;
    }
    
    .log-stats {
      animation: slideUp 0.8s ease-out forwards;
    }
    
    header {
      animation: fadeIn 0.9s ease-out forwards;
    }
    
    /* Piece animations */
    @keyframes piecePop {
      0% { transform: scale(0.5); opacity: 0.5; }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); opacity: 1; }
    }
    
    /* Win line effect */
    @keyframes winLineFlash {
      0% { opacity: 0.3; }
      50% { opacity: 1; }
      100% { opacity: 0.3; }
    }
    
    /* New styling elements */
    .tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 1000;
    }
    
    button:focus, select:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.3);
    }
    
    /* Button icon styles */
    .btn-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-right: 4px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="app-container">
    <header>
      <h1>AI 五子棋 | Gomoku</h1>
    </header>
    <!-- Fixed fullscreen button -->
    <button id="fullScreenButton">全屏模式</button>
    <div class="main-content">
      <!-- Left side: Board and timer -->
      <div class="left-panel">
        <div class="board-container">
          <canvas id="board"></canvas>
        </div>
        <div class="timer" id="moveTimer">上一步耗时：0秒</div>
      </div>
      <!-- Right side: Score, controls, status, logs and stats -->
      <div class="right-panel">
        <div class="panel-card">
          <div class="scoreboard">
            <div class="score-box">
              <span class="score-label">玩家胜：</span>
              <span id="playerScore" class="player-score">0</span>
            </div>
            <div class="score-box">
              <span class="score-label">电脑胜：</span>
              <span id="computerScore" class="computer-score">0</span>
            </div>
            <button id="resetScore"><span class="btn-icon">🔄</span>重置</button>
          </div>
        </div>
        
        <div class="panel-card controls-container">
          <div class="controls">
            <!-- Turn order dropdown -->
            <select id="turnOrder">
              <option value="player" selected>玩家先手</option>
              <option value="computer">机器人先手</option>
            </select>
            <button id="restart"><span class="btn-icon">🔄</span>重新开始</button>
            <button id="undo"><span class="btn-icon">↩️</span>悔棋</button>
            <button id="toggleSound"><span class="btn-icon">🔊</span>声音</button>
          </div>
          <div class="extra-controls">
            <button id="saveGame"><span class="btn-icon">💾</span>保存</button>
            <button id="loadGame"><span class="btn-icon">📂</span>载入</button>
            <button id="replayGame"><span class="btn-icon">▶️</span>重放</button>
          </div>
        </div>
        
        <div id="statusContainer">
          <span id="statusText">请玩家落子</span>
          <span id="spinner" style="display: none;">⏳</span>
          <span id="coordDisplay"></span>
        </div>
        
        <div class="log-stats">
          <div class="log-container" id="gameLog">
            <h2>游戏日志</h2>
          </div>
          <div class="stats">
            <h2>统计信息</h2>
            <p>总步数：<span id="totalMoves">0</span></p>
            <p>平均步时：<span id="avgMoveTime">0</span>秒</p>
            <p>最长步时：<span id="maxMoveTime">0</span>秒</p>
          </div>
        </div>
      </div>
    </div>
    <script>
      const boardSize = 15;
      const canvas = document.getElementById("board");
      const ctx = canvas.getContext("2d");
      // 添加棋盘边距（像素）
      const boardMargin = 30;
      // 线条宽度设为偶数，避免模糊
      const gridThickness = 2;
      let cellSize;
      let board = [];
      let gameOver = false;
      let waitingForComputer = false;
      let moveHistory = [];
      let lastMove = null;
      let hoverPos = null;
      let pulseAngle = 0;
      let winLine = [];
      let playerScore = 0, computerScore = 0;
      let soundEnabled = true;
      let animationEnabled = true;
      let timerEnabled = true;
      // 默认设置
      let boardBgColor = "#F3D5B5";
      let boardLineColor = "#7F5539";
      let blackPieceColor = "#0A0A0A";
      let whitePieceColor = "#F0F0F0";
      let pieceRadiusRatio = 0.38;
      let lastMoveTime = Date.now();
      let totalMoveTime = 0;
      let maxMoveTime = 0;
      const gameLog = document.getElementById("gameLog");
      // 修复tooltip持续显示问题 - 添加一个全局变量来追踪当前的tooltip
      let activeTooltip = null;
      // 设备像素比
      const dpr = window.devicePixelRatio || 1;
      // 修复多次点击重新开始的问题
      let computerMoveTimer = null;
      // 添加棋子颜色变量（五子棋规则：先手黑棋后手白棋）
      let playerPiece = 1;  // 默认玩家使用黑棋
      let computerPiece = 2;  // 默认电脑使用白棋
      
      // 解决Canvas模糊问题
      function fixCanvasBlur() {
        // 获取 canvas 的 CSS 尺寸
        const rect = canvas.getBoundingClientRect();
        
        // 设置 canvas 的物理像素尺寸
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        
        // 缩放 context 以匹配设备像素比
        ctx.scale(dpr, dpr);
        
        // 设置 CSS 尺寸（不变）
        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';
        
        // 重新计算格子大小
        cellSize = (rect.width - 2 * boardMargin) / (boardSize - 1);
      }
      
      // 设置棋盘初始尺寸
      function setCanvasSize() {
        const container = document.querySelector('.board-container');
        const containerWidth = container.clientWidth;
        
        // 保持正方形比例
        canvas.style.width = containerWidth + 'px';
        canvas.style.height = containerWidth + 'px';
        
        // 修复模糊问题
        fixCanvasBlur();
      }

      function resizeCanvas() {
        setCanvasSize();
        drawBoard();
      }

      function loadScore() {
        const storedPlayer = localStorage.getItem("gomoku_playerScore");
        const storedComputer = localStorage.getItem("gomoku_computerScore");
        if (storedPlayer !== null) playerScore = parseInt(storedPlayer);
        if (storedComputer !== null) computerScore = parseInt(storedComputer);
      }

      function saveScore() {
        localStorage.setItem("gomoku_playerScore", playerScore);
        localStorage.setItem("gomoku_computerScore", computerScore);
      }

      function saveGameState() {
        const state = { board, moveHistory, playerScore, computerScore, lastMove, totalMoveTime, maxMoveTime };
        localStorage.setItem("gomoku_gameState", JSON.stringify(state));
        addLogEntry("游戏状态已保存");
      }

      function loadGameState() {
        const stateStr = localStorage.getItem("gomoku_gameState");
        if (!stateStr) {
          addLogEntry("没有保存的游戏状态");
          return;
        }
        const state = JSON.parse(stateStr);
        board = state.board;
        moveHistory = state.moveHistory;
        playerScore = state.playerScore;
        computerScore = state.computerScore;
        lastMove = state.lastMove;
        totalMoveTime = state.totalMoveTime;
        maxMoveTime = state.maxMoveTime;
        gameOver = false;
        waitingForComputer = false;
        updateScoreboard();
        addLogEntry("游戏状态已载入");
        drawBoard();
        updateStats();
      }

      function updateStatus(message) {
        document.getElementById("statusText").innerText = message;
        document.getElementById("spinner").style.display = waitingForComputer ? "inline" : "none";
      }

      function updateScoreboard() {
        document.getElementById("playerScore").innerText = playerScore;
        document.getElementById("computerScore").innerText = computerScore;
        saveScore();
      }

      function addLogEntry(entry) {
        const p = document.createElement("p");
        p.className = "log-entry";
        p.innerHTML = `[${new Date().toLocaleTimeString()}] ${entry}`;
        p.style.animation = "fadeIn 0.3s ease-out forwards";
        gameLog.appendChild(p);
        gameLog.scrollTop = gameLog.scrollHeight;
      }

      function clearLog() {
        gameLog.innerHTML = "<h2>游戏日志</h2>";
      }

      function updateStats() {
        const totalMoves = moveHistory.length;
        document.getElementById("totalMoves").innerText = totalMoves;
        const avgTime = totalMoves ? (totalMoveTime / totalMoves).toFixed(1) : 0;
        document.getElementById("avgMoveTime").innerText = avgTime;
        document.getElementById("maxMoveTime").innerText = maxMoveTime.toFixed(1);
      }

      function updateMoveTimer() {
        if (!timerEnabled) return;
        const now = Date.now();
        const elapsed = ((now - lastMoveTime) / 1000).toFixed(1);
        document.getElementById("moveTimer").innerText = "上一步耗时：" + elapsed + "秒";
      }

      function initBoard() {
        // 清除现有的计时器
        if (computerMoveTimer) {
          clearTimeout(computerMoveTimer);
          computerMoveTimer = null;
        }
        
        board = [];
        for (let i = 0; i < boardSize; i++) {
          board[i] = [];
          for (let j = 0; j < boardSize; j++) {
            board[i][j] = 0;
          }
        }
        gameOver = false;
        waitingForComputer = false;
        moveHistory = [];
        lastMove = null;
        winLine = [];
        hoverPos = null;
        lastMoveTime = Date.now();
        totalMoveTime = 0;
        maxMoveTime = 0;
        updateStatus("请玩家落子");
        clearLog();
        updateStats();

        // Check turn order setting and set the colors
        const turnOrder = document.getElementById("turnOrder").value;
        if(turnOrder === "computer") {
          // Computer plays first, so it should use black pieces (1)
          playerPiece = 2;  // Player uses white pieces
          computerPiece = 1;  // Computer uses black pieces
          waitingForComputer = true;
          updateStatus("电脑正在思考...");
          lastMoveTime = Date.now();
          computerMoveTimer = setTimeout(computerMove, 800);
        } else {
          // Player plays first, so they should use black pieces (1)
          playerPiece = 1;  // Player uses black pieces
          computerPiece = 2;  // Computer uses white pieces
          waitingForComputer = false;
          updateStatus("请玩家落子");
        }
      }

      function drawGrid() {
        ctx.strokeStyle = boardLineColor;
        ctx.lineWidth = gridThickness;
        
        // 使用整数坐标和0.5偏移量绘制清晰的线条
        for (let i = 0; i < boardSize; i++) {
          // 计算精确的位置，避免小数点坐标
          const pos = Math.floor(boardMargin + i * cellSize) + 0.5;
          
          // 绘制水平线
          ctx.beginPath();
          ctx.moveTo(boardMargin, pos);
          ctx.lineTo(canvas.width / dpr - boardMargin, pos);
          ctx.stroke();
          
          // 绘制垂直线
          ctx.beginPath();
          ctx.moveTo(pos, boardMargin);
          ctx.lineTo(pos, canvas.height / dpr - boardMargin);
          ctx.stroke();
        }
        
        // 绘制星位点（传统交叉点）
        const starPoints = [ {x: 3, y: 3}, {x: 11, y: 3}, {x: 3, y: 11}, {x: 11, y: 11}, {x: 7, y: 7} ];
        ctx.fillStyle = "#5a3e2b";
        for (const point of starPoints) {
          ctx.beginPath();
          // 确保星位点在正确的整数位置
          const x = Math.floor(boardMargin + point.x * cellSize) + 0.5;
          const y = Math.floor(boardMargin + point.y * cellSize) + 0.5;
          ctx.arc(x, y, Math.floor(cellSize * 0.12), 0, 2 * Math.PI);
          ctx.fill();
        }
      }

      function drawPieces() {
        for (let i = 0; i < boardSize; i++) {
          for (let j = 0; j < boardSize; j++) {
            if (board[i][j] !== 0) {
              drawPiece(i, j, board[i][j]);
            }
          }
        }
      }

      function drawPiece(i, j, color) {
        // 确保坐标是整数
        const x = Math.floor(boardMargin + i * cellSize) + 0.5;
        const y = Math.floor(boardMargin + j * cellSize) + 0.5;
        const radius = Math.floor(cellSize * pieceRadiusRatio);
        
        // 棋子阴影
        ctx.beginPath();
        ctx.arc(x + 2, y + 2, radius, 0, 2 * Math.PI);
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.fill();
        
        // 棋子主体
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        let gradient = ctx.createRadialGradient(x - radius/3, y - radius/3, radius * 0.1, x, y, radius);
        if (color === 1) {
          gradient.addColorStop(0, "#444");
          gradient.addColorStop(1, blackPieceColor);
        } else {
          gradient.addColorStop(0, whitePieceColor);
          gradient.addColorStop(1, "#ccc");
        }
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // 棋子高光
        ctx.beginPath();
        ctx.arc(x - radius*0.2, y - radius*0.2, radius * 0.15, 0, 2 * Math.PI);
        ctx.fillStyle = color === 1 ? "rgba(255,255,255,0.2)" : "rgba(255,255,255,0.8)";
        ctx.fill();
        
        // 最后一步标记
        if (animationEnabled && lastMove && lastMove.x === i && lastMove.y === j) {
          const pulse = 3 + Math.sin(pulseAngle) * 2;
          ctx.strokeStyle = "rgba(255,0,0,0.7)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(x, y, radius + pulse, 0, 2 * Math.PI);
          ctx.stroke();
        }
        
        // 胜利线标记
        if (winLine.some(pt => pt.x === i && pt.y === j)) {
          ctx.strokeStyle = "rgba(255,215,0,0.8)";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(x, y, radius * 1.2, 0, 2 * Math.PI);
          ctx.stroke();
          
          const flashIntensity = 0.5 + Math.sin(pulseAngle * 2) * 0.3;
          ctx.fillStyle = `rgba(255,215,0,${flashIntensity})`;
          ctx.beginPath();
          ctx.arc(x, y, radius * 0.6, 0, 2 * Math.PI);
          ctx.fill();
        }
      }

      function drawBoard() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 绘制棋盘背景
        ctx.fillStyle = boardBgColor;
        ctx.fillRect(0, 0, canvas.width / dpr, canvas.height / dpr);
        
        // 绘制网格和棋子
        drawGrid();
        drawPieces();
        
        // 悬浮效果
        if (!gameOver && !waitingForComputer && hoverPos) {
          const hx = Math.floor(boardMargin + hoverPos.x * cellSize) + 0.5;
          const hy = Math.floor(boardMargin + hoverPos.y * cellSize) + 0.5;
          ctx.beginPath();
          ctx.arc(hx, hy, Math.floor(cellSize * pieceRadiusRatio), 0, 2 * Math.PI);
          ctx.fillStyle = "rgba(0,0,0,0.15)";
          ctx.fill();
          ctx.strokeStyle = "rgba(0,0,0,0.3)";
          ctx.lineWidth = 1;
          ctx.stroke();
        }
      }

      function getWinningLine(x, y, color) {
        const directions = [
          { dx: 1, dy: 0 },  // horizontal
          { dx: 0, dy: 1 },  // vertical
          { dx: 1, dy: 1 },  // diagonal down-right
          { dx: 1, dy: -1 }  // diagonal up-right
        ];
        for (const { dx, dy } of directions) {
          let line = [{ x, y }];
          // Check forward direction
          for (let i = 1;; i++) {
            const nx = x + dx * i, ny = y + dy * i;
            if (nx < 0 || nx >= boardSize || ny < 0 || ny >= boardSize || board[nx][ny] !== color) break;
            line.push({ x: nx, y: ny });
          }
          // Check backward direction
          for (let i = 1;; i++) {
            const nx = x - dx * i, ny = y - dy * i;
            if (nx < 0 || nx >= boardSize || ny < 0 || ny >= boardSize || board[nx][ny] !== color) break;
            line.unshift({ x: nx, y: ny });
          }
          if (line.length >= 5) return line;
        }
        return null;
      }

      function checkDraw() {
        for (let i = 0; i < boardSize; i++) {
          for (let j = 0; j < boardSize; j++) {
            if (board[i][j] === 0) return false;
          }
        }
        return true;
      }

      function getCandidateMoves() {
        const candidates = [];
        const searchRange = 2;
        const visited = Array(boardSize).fill().map(() => Array(boardSize).fill(false));
        
        // Check if board is empty
        let hasStone = false;
        for (let i = 0; i < boardSize; i++) {
          for (let j = 0; j < boardSize; j++) {
            if (board[i][j] !== 0) { hasStone = true; break; }
          }
          if (hasStone) break;
        }
        
        // If board is empty, play in the center
        if (!hasStone) {
          return [{ x: Math.floor(boardSize / 2), y: Math.floor(boardSize / 2) }];
        }
        
        // Otherwise find empty positions near existing pieces
        for (let i = 0; i < boardSize; i++) {
          for (let j = 0; j < boardSize; j++) {
            if (board[i][j] !== 0) {
              for (let dx = -searchRange; dx <= searchRange; dx++) {
                for (let dy = -searchRange; dy <= searchRange; dy++) {
                  const nx = i + dx, ny = j + dy;
                  if (nx < 0 || nx >= boardSize || ny < 0 || ny >= boardSize || visited[nx][ny]) continue;
                  if (board[nx][ny] === 0) {
                    candidates.push({ x: nx, y: ny });
                    visited[nx][ny] = true;
                  }
                }
              }
            }
          }
        }
        
        // Fallback to center if no candidates found
        if (candidates.length === 0) {
          return [{ x: Math.floor(boardSize / 2), y: Math.floor(boardSize / 2) }];
        }
        return candidates;
      }

      function evaluatePoint(x, y, color) {
        let score = 0;
        const directions = [
          { dx: 1, dy: 0 },  // horizontal
          { dx: 0, dy: 1 },  // vertical
          { dx: 1, dy: 1 },  // diagonal down-right
          { dx: 1, dy: -1 }  // diagonal up-right
        ];
        
        // Temporarily place the piece
        board[x][y] = color;
        
        // Check in all directions
        for (const { dx, dy } of directions) {
          let count = 1, openEnds = 0;
          let blocked = false;
          
          // Check forward direction
          for (let i = 1; i < 5; i++) {
            const nx = x + dx * i, ny = y + dy * i;
            if (nx < 0 || nx >= boardSize || ny < 0 || ny >= boardSize) { blocked = true; break; }
            if (board[nx][ny] === color) { count++; }
            else if (board[nx][ny] === 0) { openEnds++; break; }
            else { blocked = true; break; }
          }
          
          // Check backward direction
          let blocked2 = false;
          for (let i = 1; i < 5; i++) {
            const nx = x - dx * i, ny = y - dy * i;
            if (nx < 0 || nx >= boardSize || ny < 0 || ny >= boardSize) { blocked2 = true; break; }
            if (board[nx][ny] === color) { count++; }
            else if (board[nx][ny] === 0) { openEnds++; break; }
            else { blocked2 = true; break; }
          }
          
          score += getLineScore(count, openEnds, blocked && blocked2);
        }
        
        // Remove the temporarily placed piece
        board[x][y] = 0;
        return score;
      }

      function getLineScore(count, openEnds, fullyBlocked) {
        if (count >= 5) return 100000;  // Win
        if (fullyBlocked) return count;  // Blocked on both sides is less valuable
        
        switch (count) {
          case 4: return openEnds === 2 ? 20000 : (openEnds === 1 ? 5000 : 0);  // Four in a row
          case 3: return openEnds === 2 ? 5000 : (openEnds === 1 ? 800 : 0);    // Three in a row
          case 2: return openEnds === 2 ? 650 : (openEnds === 1 ? 150 : 0);     // Two in a row
          case 1: return openEnds === 2 ? 10 : 0;                              // One with space
        }
        return 0;
      }

      function getMoveScore(x, y) {
        const scoreAI = evaluatePoint(x, y, computerPiece);      // 使用computerPiece而不是硬编码的2
        const scoreHuman = evaluatePoint(x, y, playerPiece);   // 使用playerPiece而不是硬编码的1
        
        // Difficulty weights
        const offenseWeight = 1.1;  // Weight for AI's own moves
        const defenseWeight = 1.2;  // Weight for blocking human moves
        
        // Add position bonus (center is preferred)
        const centerX = boardSize / 2;
        const centerY = boardSize / 2;
        const distanceFromCenter = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
        const positionBonus = Math.max(0, 30 - distanceFromCenter * 2);
        
        return (scoreAI * offenseWeight) + (scoreHuman * defenseWeight) + positionBonus;
      }

      function getAIMove() {
        const candidates = getCandidateMoves();
        let bestMove = null, bestScore = -Infinity;
        
        for (const m of candidates) {
          const currentScore = getMoveScore(m.x, m.y);
          
          // If winning move found, return immediately
          if (currentScore >= 90000) return m;
          
          // Simulate this move and check opponent's response
          board[m.x][m.y] = computerPiece;  // 使用computerPiece而不是硬编码的2
          const oppCandidates = getCandidateMoves();
          let oppBestScore = 0;
          
          for (const om of oppCandidates) {
            if (board[om.x][om.y] !== 0) continue;
            const oppScore = evaluatePoint(om.x, om.y, playerPiece);  // 使用playerPiece而不是硬编码的1
            if (oppScore > oppBestScore) oppBestScore = oppScore;
          }
          
          // Undo the simulation
          board[m.x][m.y] = 0;
          
          // Calculate net score (offensive value minus defensive risk)
          const netScore = currentScore - (oppBestScore * 0.8);
          if (netScore > bestScore) { 
            bestScore = netScore; 
            bestMove = m; 
          }
        }
        
        return bestMove;
      }

      function playSound() {
        if (!soundEnabled) return;
        try {
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const oscillator = audioCtx.createOscillator();
          const gainNode = audioCtx.createGain();
          
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(500, audioCtx.currentTime);
          oscillator.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.3);
          
          gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
          
          oscillator.connect(gainNode);
          gainNode.connect(audioCtx.destination);
          oscillator.start();
          oscillator.stop(audioCtx.currentTime + 0.3);
        } catch (e) {
          console.error("无法播放音效:", e);
        }
      }

      function handlePlayerMove(e) {
        if (gameOver || waitingForComputer) return;
        
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = (e.clientX - rect.left) * scaleX / dpr;
        const y = (e.clientY - rect.top) * scaleY / dpr;
        
        // Don't process clicks outside the board grid
        if(x < boardMargin || x > canvas.width / dpr - boardMargin || 
           y < boardMargin || y > canvas.height / dpr - boardMargin) return;
           
        const i = Math.round((x - boardMargin) / cellSize);
        const j = Math.round((y - boardMargin) / cellSize);
        
        if (i < 0 || i >= boardSize || j < 0 || j >= boardSize) return;
        if (board[i][j] !== 0) return;  // Space already occupied
        
        // Player's move - 使用playerPiece而不是硬编码的1
        board[i][j] = playerPiece;
        const moveTime = (Date.now() - lastMoveTime) / 1000;
        totalMoveTime += moveTime;
        if (moveTime > maxMoveTime) maxMoveTime = moveTime;
        
        moveHistory.push({ x: i, y: j, color: playerPiece, time: moveTime });
        lastMove = { x: i, y: j };
        playSound();
        addLogEntry(`玩家落子：(${i}, ${j}) 耗时：${moveTime.toFixed(1)}秒`);
        updateStats();
        drawBoard();
        
        // Check for win
        const line = getWinningLine(i, j, playerPiece);
        if (line) {
          winLine = line;
          gameOver = true;
          playerScore++;
          updateScoreboard();
          updateStatus("🎉 玩家获胜！");
          addLogEntry("结果：玩家获胜！");
          return;
        }
        
        // Check for draw
        if (checkDraw()) {
          gameOver = true;
          updateStatus("⚖️ 平局！");
          addLogEntry("结果：平局");
          return;
        }
        
        // Computer's turn
        updateStatus("电脑正在思考...");
        waitingForComputer = true;
        lastMoveTime = Date.now();
        computerMoveTimer = setTimeout(computerMove, 800);
      }

      function computerMove() {
        if (gameOver) return;
        
        const move = getAIMove();
        if (!move) return;
        
        // Computer makes its move - 使用computerPiece而不是硬编码的2
        board[move.x][move.y] = computerPiece;
        const moveTime = (Date.now() - lastMoveTime) / 1000;
        totalMoveTime += moveTime;
        if (moveTime > maxMoveTime) maxMoveTime = moveTime;
        
        moveHistory.push({ x: move.x, y: move.y, color: computerPiece, time: moveTime });
        lastMove = { x: move.x, y: move.y };
        playSound();
        addLogEntry(`电脑落子：(${move.x}, ${move.y}) 耗时：${moveTime.toFixed(1)}秒`);
        updateStats();
        drawBoard();
        
        // Check for win
        const line = getWinningLine(move.x, move.y, computerPiece);
        if (line) {
          winLine = line;
          gameOver = true;
          computerScore++;
          updateScoreboard();
          updateStatus("💻 电脑获胜！");
          addLogEntry("结果：电脑获胜！");
          waitingForComputer = false;
          return;
        }
        
        // Check for draw
        if (checkDraw()) {
          gameOver = true;
          updateStatus("⚖️ 平局！");
          addLogEntry("结果：平局");
          waitingForComputer = false;
          return;
        }
        
        // Player's turn
        waitingForComputer = false;
        updateStatus("请玩家落子");
        lastMoveTime = Date.now();
      }

      function undoMove() {
        if (moveHistory.length === 0) return;
        
        gameOver = false;
        winLine = [];
        
        // Undo computer move first (if it exists)
        if (moveHistory.length > 0 && moveHistory[moveHistory.length - 1].color === computerPiece) {
          const move = moveHistory.pop();
          board[move.x][move.y] = 0;
          addLogEntry(`悔棋：撤销电脑落子 (${move.x}, ${move.y})`);
        }
        
        // Then undo player move
        if (moveHistory.length > 0 && moveHistory[moveHistory.length - 1].color === playerPiece) {
          const move = moveHistory.pop();
          board[move.x][move.y] = 0;
          addLogEntry(`悔棋：撤销玩家落子 (${move.x}, ${move.y})`);
        }
        
        // Update last move
        lastMove = moveHistory.length > 0 ? 
          { x: moveHistory[moveHistory.length - 1].x, y: moveHistory[moveHistory.length - 1].y } : null;
        
        waitingForComputer = false;
        updateStatus("请玩家落子");
        updateStats();
        drawBoard();
      }

      function replayGame() {
        if (moveHistory.length === 0) {
          addLogEntry("没有可重放的记录");
          return;
        }
        
        updateStatus("🎬 正在重放游戏...");
        let replayIndex = 0;
        const savedHistory = JSON.parse(JSON.stringify(moveHistory));
        const savedPlayerPiece = playerPiece;  // 保存当前的棋子颜色设置
        const savedComputerPiece = computerPiece;
        
        initBoard();
        
        const replayInterval = setInterval(() => {
          if (replayIndex >= savedHistory.length) {
            clearInterval(replayInterval);
            updateStatus("重放结束，等待玩家落子");
            return;
          }
          
          const move = savedHistory[replayIndex];
          board[move.x][move.y] = move.color;
          lastMove = { x: move.x, y: move.y };
          addLogEntry(`重放：${move.color === savedPlayerPiece ? "玩家" : "电脑"} (${move.x}, ${move.y})`);
          replayIndex++;
          drawBoard();
          
          if (soundEnabled) playSound();
        }, 500);
      }

      function render() {
        pulseAngle += 0.05;
        drawBoard();
        if (timerEnabled) updateMoveTimer();
        requestAnimationFrame(render);
      }

      function handleKeyDown(e) {
        if (e.key.toLowerCase() === 'u') {
          undoMove();
        } else if (e.key.toLowerCase() === 'r') {
          initBoard();
          updateStatus("请玩家落子");
          addLogEntry("游戏重新开始");
          drawBoard();
        }
      }

      function coordToString(i, j) {
        const row = String.fromCharCode(65 + i);
        return row + (j + 1);
      }

      canvas.addEventListener("mousemove", function(e) {
        if (gameOver || waitingForComputer) {
          hoverPos = null;
          document.getElementById("coordDisplay").innerText = "";
          return;
        }
        
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = (e.clientX - rect.left) * scaleX / dpr;
        const y = (e.clientY - rect.top) * scaleY / dpr;
        
        if(x < boardMargin || x > canvas.width / dpr - boardMargin || 
           y < boardMargin || y > canvas.height / dpr - boardMargin) {
          hoverPos = null;
          document.getElementById("coordDisplay").innerText = "";
          return;
        }
        
        const i = Math.round((x - boardMargin) / cellSize);
        const j = Math.round((y - boardMargin) / cellSize);
        
        if (i < 0 || i >= boardSize || j < 0 || j >= boardSize || board[i][j] !== 0) {
          hoverPos = null;
          document.getElementById("coordDisplay").innerText = "";
        } else {
          hoverPos = { x: i, y: j };
          document.getElementById("coordDisplay").innerText = "坐标：" + coordToString(i, j);
        }
      });

      canvas.addEventListener("mouseout", function() {
        hoverPos = null;
        document.getElementById("coordDisplay").innerText = "";
      });

      // 修复了tooltip函数，确保只有一个tooltip显示并正确移除
      function addTooltip(element, text) {
        element.addEventListener("mouseenter", function(e) {
          // 先移除任何已存在的tooltip
          if (activeTooltip) {
            activeTooltip.remove();
            activeTooltip = null;
          }
          
          const tooltip = document.createElement("div");
          tooltip.className = "tooltip";
          tooltip.textContent = text;
          tooltip.style.left = e.clientX + "px";
          tooltip.style.top = (e.clientY + 20) + "px";
          document.body.appendChild(tooltip);
          activeTooltip = tooltip;
          setTimeout(() => {
            if (activeTooltip === tooltip) {
              tooltip.style.opacity = "1";
            }
          }, 10);
        });
        
        element.addEventListener("mousemove", function(e) {
          if (activeTooltip) {
            activeTooltip.style.left = e.clientX + "px";
            activeTooltip.style.top = (e.clientY + 20) + "px";
          }
        });
        
        element.addEventListener("mouseleave", function() {
          if (activeTooltip) {
            activeTooltip.style.opacity = "0";
            const tooltipToRemove = activeTooltip;
            activeTooltip = null;
            setTimeout(() => {
              if (tooltipToRemove && tooltipToRemove.parentNode) {
                tooltipToRemove.remove();
              }
            }, 300);
          }
        });
      }

      // 添加一个全局鼠标移动事件来处理tooltip的边缘情况
      document.addEventListener("mousemove", function(e) {
        // 检查鼠标是否离开了任何可能有tooltip的元素
        const elementsUnderCursor = document.elementsFromPoint(e.clientX, e.clientY);
        const hasTooltipParent = elementsUnderCursor.some(el => {
          return el.tagName === "BUTTON" || el.tagName === "SELECT";
        });
        
        // 如果鼠标不在任何相关元素上但仍有tooltip，则移除它
        if (!hasTooltipParent && activeTooltip) {
          activeTooltip.style.opacity = "0";
          const tooltipToRemove = activeTooltip;
          activeTooltip = null;
          setTimeout(() => {
            if (tooltipToRemove && tooltipToRemove.parentNode) {
              tooltipToRemove.remove();
            }
          }, 300);
        }
      });

      function initGame() {
        setCanvasSize();
        window.addEventListener("resize", resizeCanvas);
        loadScore();
        updateScoreboard();
        initBoard();
        drawBoard();
        render();
        
        canvas.addEventListener("click", handlePlayerMove);
        
        // Main control buttons
        document.getElementById("restart").addEventListener("click", function() {
          initBoard();
          updateStatus("请玩家落子");
          addLogEntry("游戏重新开始");
        });
        
        document.getElementById("resetScore").addEventListener("click", function() {
          playerScore = 0;
          computerScore = 0;
          updateScoreboard();
          initBoard();
          addLogEntry("记分已重置");
        });
        
        document.getElementById("undo").addEventListener("click", function() {
          undoMove();
        });
        
        document.getElementById("toggleSound").addEventListener("click", function() {
          soundEnabled = !soundEnabled;
          this.innerHTML = soundEnabled ? 
            '<span class="btn-icon">🔊</span>声音' : 
            '<span class="btn-icon">🔇</span>静音';
          addLogEntry("声音设置：" + (soundEnabled ? "开" : "关"));
        });
        
        // Game state buttons
        document.getElementById("saveGame").addEventListener("click", saveGameState);
        document.getElementById("loadGame").addEventListener("click", loadGameState);
        document.getElementById("replayGame").addEventListener("click", replayGame);
        
        // Fullscreen button
        document.getElementById("fullScreenButton").addEventListener("click", function() {
          if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
            this.textContent = "退出全屏";
          } else {
            if (document.exitFullscreen) {
              document.exitFullscreen();
              this.textContent = "全屏模式";
            }
          }
        });
        
        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyDown);
        
        // Add tooltips
        addTooltip(document.getElementById("restart"), "重新开始游戏 (快捷键: R)");
        addTooltip(document.getElementById("undo"), "撤销上一步操作 (快捷键: U)");
        addTooltip(document.getElementById("saveGame"), "保存当前游戏状态");
        addTooltip(document.getElementById("loadGame"), "加载保存的游戏状态");
        addTooltip(document.getElementById("fullScreenButton"), "切换全屏模式");
        
        const turnOrder = document.getElementById("turnOrder").value;
        addLogEntry("游戏初始化完成，先后手：" + (turnOrder === "computer" ? "机器人先手" : "玩家先手"));
      }

      // Initialize game when page loads
      window.addEventListener("load", initGame);
    </script>
  </div>
</body>
</html>